# STM32 + MAX30102 心率监测模块对接指南

## 一、系统架构

```
┌─────────────────┐      I²C       ┌──────────────┐
│   MAX30102      │◄──────────────►│    STM32     │
│ 心率血氧传感器   │                │   主控MCU    │
└─────────────────┘                └──────┬───────┘
                                          │ UART
                                   ┌──────▼───────┐
                                   │   ESP8266    │
                                   │  WiFi模块    │
                                   └──────┬───────┘
                                          │ HTTP POST
                                   ┌──────▼───────┐
                                   │   FastAPI    │
                                   │  后端服务     │
                                   │ :8000/api/iot│
                                   └──────────────┘
```

## 二、硬件连接

### MAX30102 → STM32 (I²C)

| MAX30102 引脚 | STM32 引脚 | 说明 |
|---------------|------------|------|
| VCC | 3.3V | 电源 |
| GND | GND | 接地 |
| SDA | PB7 (I2C1_SDA) | 数据线 |
| SCL | PB6 (I2C1_SCL) | 时钟线 |
| INT | PA0 (GPIO_EXTI) | 中断（可选） |

### ESP8266 → STM32 (UART)

| ESP8266 引脚 | STM32 引脚 | 说明 |
|--------------|------------|------|
| VCC | 3.3V | 电源 |
| GND | GND | 接地 |
| TX | PA10 (USART1_RX) | 数据接收 |
| RX | PA9 (USART1_TX) | 数据发送 |
| EN | 3.3V | 使能 |

## 三、STM32 固件代码

### 3.1 I²C 读取 MAX30102 数据

```c
// max30102.h
#ifndef __MAX30102_H
#define __MAX30102_H

#include "stm32f1xx_hal.h"

#define MAX30102_ADDR           0xAE  // 7位地址左移1位
#define REG_INTR_STATUS_1       0x00
#define REG_FIFO_WR_PTR         0x04
#define REG_FIFO_RD_PTR         0x06
#define REG_FIFO_DATA           0x07
#define REG_MODE_CONFIG         0x09
#define REG_SPO2_CONFIG         0x0A
#define REG_LED1_PA             0x0C  // RED
#define REG_LED2_PA             0x0D  // IR

typedef struct {
    uint32_t red;     // 红光原始值
    uint32_t ir;      // 红外光原始值
    int heart_rate;   // 计算后的心率
    float spo2;       // 计算后的血氧
} MAX30102_Data;

HAL_StatusTypeDef MAX30102_Init(I2C_HandleTypeDef *hi2c);
HAL_StatusTypeDef MAX30102_ReadFIFO(I2C_HandleTypeDef *hi2c, MAX30102_Data *data);
void MAX30102_CalcHRSpO2(MAX30102_Data *data);

#endif
```

```c
// max30102.c
#include "max30102.h"

static I2C_HandleTypeDef *_hi2c;

HAL_StatusTypeDef MAX30102_Init(I2C_HandleTypeDef *hi2c) {
    _hi2c = hi2c;
    uint8_t config;
    
    // 复位
    config = 0x40;
    HAL_I2C_Mem_Write(hi2c, MAX30102_ADDR, REG_MODE_CONFIG, 1, &config, 1, 100);
    HAL_Delay(100);
    
    // 配置SPO2模式
    config = 0x03;  // SpO2 mode
    HAL_I2C_Mem_Write(hi2c, MAX30102_ADDR, REG_MODE_CONFIG, 1, &config, 1, 100);
    
    // 配置采样率、脉冲宽度
    config = 0x27;  // 100Hz, 411us pulse
    HAL_I2C_Mem_Write(hi2c, MAX30102_ADDR, REG_SPO2_CONFIG, 1, &config, 1, 100);
    
    // 配置LED电流
    config = 0x24;  // 7.2mA
    HAL_I2C_Mem_Write(hi2c, MAX30102_ADDR, REG_LED1_PA, 1, &config, 1, 100);
    HAL_I2C_Mem_Write(hi2c, MAX30102_ADDR, REG_LED2_PA, 1, &config, 1, 100);
    
    return HAL_OK;
}

HAL_StatusTypeDef MAX30102_ReadFIFO(I2C_HandleTypeDef *hi2c, MAX30102_Data *data) {
    uint8_t fifo_data[6];
    
    HAL_I2C_Mem_Read(hi2c, MAX30102_ADDR, REG_FIFO_DATA, 1, fifo_data, 6, 100);
    
    // 解析 18-bit ADC 数据
    data->red = ((fifo_data[0] << 16) | (fifo_data[1] << 8) | fifo_data[2]) & 0x3FFFF;
    data->ir = ((fifo_data[3] << 16) | (fifo_data[4] << 8) | fifo_data[5]) & 0x3FFFF;
    
    return HAL_OK;
}

// 简化的心率血氧计算（实际需要更复杂的滤波算法）
void MAX30102_CalcHRSpO2(MAX30102_Data *data) {
    // 基于 RED/IR 比值计算 SpO2
    float ratio = (float)data->red / (float)data->ir;
    data->spo2 = 110.0f - 25.0f * ratio;  // 经验公式
    if (data->spo2 > 100) data->spo2 = 100;
    if (data->spo2 < 70) data->spo2 = 70;
    
    // 心率需要通过峰值检测算法计算（此处简化）
    data->heart_rate = 75;  // 默认值，需实现峰值检测
}
```

### 3.2 ESP8266 HTTP POST 发送数据

```c
// esp8266.h
#ifndef __ESP8266_H
#define __ESP8266_H

#include "stm32f1xx_hal.h"

#define ESP_UART        huart1
#define SERVER_IP       "192.168.1.100"  // 你的 FastAPI 服务器 IP
#define SERVER_PORT     "8000"
#define API_ENDPOINT    "/api/iot/vitals/upload"

HAL_StatusTypeDef ESP8266_Init(UART_HandleTypeDef *huart);
HAL_StatusTypeDef ESP8266_ConnectWiFi(const char *ssid, const char *password);
HAL_StatusTypeDef ESP8266_SendVitals(int heart_rate, float spo2, const char *device_id);

#endif
```

```c
// esp8266.c
#include "esp8266.h"
#include <stdio.h>
#include <string.h>

static UART_HandleTypeDef *_huart;
static char tx_buffer[512];
static char rx_buffer[256];

// 发送AT指令并等待响应
static HAL_StatusTypeDef ESP_SendCmd(const char *cmd, const char *expect, uint32_t timeout) {
    HAL_UART_Transmit(_huart, (uint8_t*)cmd, strlen(cmd), 1000);
    HAL_UART_Transmit(_huart, (uint8_t*)"\r\n", 2, 100);
    
    memset(rx_buffer, 0, sizeof(rx_buffer));
    HAL_UART_Receive(_huart, (uint8_t*)rx_buffer, sizeof(rx_buffer)-1, timeout);
    
    return (strstr(rx_buffer, expect) != NULL) ? HAL_OK : HAL_ERROR;
}

HAL_StatusTypeDef ESP8266_Init(UART_HandleTypeDef *huart) {
    _huart = huart;
    
    // 测试AT
    if (ESP_SendCmd("AT", "OK", 1000) != HAL_OK) return HAL_ERROR;
    
    // 设置为Station模式
    ESP_SendCmd("AT+CWMODE=1", "OK", 1000);
    
    return HAL_OK;
}

HAL_StatusTypeDef ESP8266_ConnectWiFi(const char *ssid, const char *password) {
    sprintf(tx_buffer, "AT+CWJAP=\"%s\",\"%s\"", ssid, password);
    return ESP_SendCmd(tx_buffer, "WIFI CONNECTED", 10000);
}

HAL_StatusTypeDef ESP8266_SendVitals(int heart_rate, float spo2, const char *device_id) {
    // 1. 建立TCP连接
    sprintf(tx_buffer, "AT+CIPSTART=\"TCP\",\"%s\",%s", SERVER_IP, SERVER_PORT);
    if (ESP_SendCmd(tx_buffer, "CONNECT", 5000) != HAL_OK) return HAL_ERROR;
    
    // 2. 构造JSON数据
    char json_body[128];
    sprintf(json_body, "{\"heart_rate\":%d,\"spo2\":%.1f,\"device_id\":\"%s\"}", 
            heart_rate, spo2, device_id);
    
    // 3. 构造HTTP请求
    char http_request[384];
    sprintf(http_request, 
        "POST %s HTTP/1.1\r\n"
        "Host: %s:%s\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "%s",
        API_ENDPOINT, SERVER_IP, SERVER_PORT, strlen(json_body), json_body);
    
    // 4. 发送数据长度
    sprintf(tx_buffer, "AT+CIPSEND=%d", strlen(http_request));
    if (ESP_SendCmd(tx_buffer, ">", 2000) != HAL_OK) return HAL_ERROR;
    
    // 5. 发送HTTP请求
    HAL_UART_Transmit(_huart, (uint8_t*)http_request, strlen(http_request), 5000);
    
    // 6. 等待响应
    HAL_Delay(1000);
    
    // 7. 关闭连接
    ESP_SendCmd("AT+CIPCLOSE", "CLOSED", 1000);
    
    return HAL_OK;
}
```

### 3.3 主程序循环

```c
// main.c (主循环部分)
#include "max30102.h"
#include "esp8266.h"

#define DEVICE_ID       "STM32_MAX30102_001"
#define WIFI_SSID       "YourWiFiName"
#define WIFI_PASSWORD   "YourWiFiPassword"
#define UPLOAD_INTERVAL 5000  // 5秒上传一次

int main(void) {
    HAL_Init();
    SystemClock_Config();
    
    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_USART1_UART_Init();
    
    // 初始化传感器
    MAX30102_Init(&hi2c1);
    
    // 初始化WiFi
    ESP8266_Init(&huart1);
    ESP8266_ConnectWiFi(WIFI_SSID, WIFI_PASSWORD);
    
    MAX30102_Data vital_data;
    uint32_t last_upload = 0;
    
    while (1) {
        // 读取传感器数据
        MAX30102_ReadFIFO(&hi2c1, &vital_data);
        MAX30102_CalcHRSpO2(&vital_data);
        
        // 定时上传
        if (HAL_GetTick() - last_upload >= UPLOAD_INTERVAL) {
            ESP8266_SendVitals(vital_data.heart_rate, vital_data.spo2, DEVICE_ID);
            last_upload = HAL_GetTick();
        }
        
        HAL_Delay(50);  // 50ms采样间隔
    }
}
```

## 四、后端 API 接口

### 4.1 上传生命体征数据

**请求**
```http
POST /api/iot/vitals/upload HTTP/1.1
Host: 192.168.1.100:8000
Content-Type: application/json

{
  "heart_rate": 75,
  "spo2": 98.5,
  "device_id": "STM32_MAX30102_001"
}
```

**响应**
```json
{
  "status": "success",
  "message": "数据接收成功",
  "device_id": "STM32_MAX30102_001",
  "alert": null
}
```

### 4.2 获取最新数据

```http
GET /api/iot/vitals/latest?device_id=STM32_MAX30102_001&limit=10
```

### 4.3 WebSocket 实时推送

```javascript
// 前端订阅实时数据
const ws = new WebSocket('ws://192.168.1.100:8000/api/iot/ws/vitals');
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('实时心率:', data.heart_rate);
};
```

## 五、测试命令

### 使用 curl 模拟 STM32 上传

```bash
# 上传心率数据
curl -X POST "http://localhost:8000/api/iot/vitals/upload" \
  -H "Content-Type: application/json" \
  -d '{"heart_rate": 78, "spo2": 97.5, "device_id": "STM32_TEST_001"}'

# 查看最新数据
curl "http://localhost:8000/api/iot/vitals/latest"

# 查看设备状态
curl "http://localhost:8000/api/iot/devices/status"
```

## 六、注意事项

1. **网络配置**：确保 STM32 和 FastAPI 服务器在同一局域网
2. **防火墙**：服务器需开放 8000 端口
3. **数据校验**：后端已添加心率 30-220、血氧 70-100 的范围校验
4. **异常告警**：心率 <50 或 >100、血氧 <94 会返回告警信息
5. **批量上传**：网络不稳定时可缓存后批量上传到 `/api/iot/vitals/batch`
