# 数据分析师技术总结

> 养生之道智能健康管理系统 - 数据清洗/处理、可视化分析、硬件数据采集（STM32+MAX30102）

---

## 一、负责模块概览

| 模块 | 技术栈 | 核心职责 |
|------|--------|----------|
| **数据清洗/处理** | Python + NumPy/Pandas | IQR异常值检测、Z-score标准化、缺失值填充 |
| **可视化分析** | React + Recharts | 前端数据图表、健康趋势可视化 |
| **硬件数据采集** | STM32 + MAX30102 | 心率血氧传感器驱动、I2C通信、数据上传 |

---

## 二、技术架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        数据采集与处理架构                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────┐      I2C通信        ┌─────────────┐                   │
│   │  MAX30102   │ ───────────────────► │   STM32     │                   │
│   │ 心率血氧传感器│                      │  单片机     │                   │
│   │ (红光+红外LED)│                      │ (Cortex-M3) │                   │
│   └─────────────┘                      └──────┬──────┘                   │
│                                               │ 串口/WiFi                 │
│                                               ▼                          │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │                      FastAPI 后端                                  │  │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│   │  │ 数据接收  │→ │ 数据清洗  │→ │ 特征工程  │→ │ 健康评估  │          │  │
│   │  │ API接口   │  │ IQR/Zscore│  │ 统计+趋势 │  │ 综合评分  │          │  │
│   │  └──────────┘  └──────────┘  └──────────┘  └──────────┘          │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                               │                          │
│                                               ▼                          │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │                    React 前端可视化                               │  │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│   │  │ 心率曲线  │  │ 血氧趋势  │  │ 健康雷达  │  │ 数据看板  │          │  │
│   │  │ LineChart │  │ AreaChart │  │RadarChart │  │ Dashboard │          │  │
│   │  └──────────┘  └──────────┘  └──────────┘  └──────────┘          │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 三、代码文件清单

### 3.1 Python 数据处理模块

| 目录 | 文件 | 功能 | 代码行数 |
|------|------|------|----------|
| **数据层/** | `data_pipeline.py` | 数据采集 + 清洗流水线 | 945 行 |
| | `data_preparation.py` | 特征工程模块 | 530 行 |
| **modules/** | `indicator_evaluator.py` | 指标评估器 | 356 行 |

### 3.2 STM32 硬件驱动代码

| 目录 | 文件 | 功能 | 代码行数 |
|------|------|------|----------|
| **HARDWARE/IIC/** | `max30102.c` | MAX30102传感器驱动 | 380 行 |
| | `algorithm.c` | 心率血氧算法 | 379 行 |
| | `myiic.c` | I2C通信驱动 | ~100 行 |
| **USER/** | `main.c` | 主程序+数据滤波 | 273 行 |

### 3.3 前端可视化模块

| 目录 | 文件 | 功能 |
|------|------|------|
| **components/** | `HealthCharts.tsx` | Recharts图表组件 |
| | `BigScreenDashboard.tsx` | 社区数据大屏 |

**总代码量**：约 **3,000+ 行** Python + **1,000+ 行** C + **2,000+ 行** TypeScript

---

## 四、硬件数据采集（STM32 + MAX30102）

### 4.1 硬件连接图

```
STM32F103 ─────────────────── MAX30102
   │                              │
   │ VCC ◄─────────────────────► 3.3V
   │ GND ◄─────────────────────► GND
   │ PB7 ◄─────────────────────► SCL (I2C时钟)
   │ PB8 ◄─────────────────────► SDA (I2C数据)
   │ PB9 ◄─────────────────────► INT (中断信号)
   │
   │ PA9 ────────────────────────► USB-TTL RXD
   │ PA10 ◄──────────────────────  USB-TTL TXD
```

### 4.2 MAX30102 传感器特性

| 参数 | 值 | 说明 |
|------|-----|------|
| **工作电压** | 1.8V ~ 3.3V | 低功耗设计 |
| **测量原理** | PPG光电容积脉搏波 | 红光+红外双波长 |
| **采样率** | 50~3200 sps | 可配置 |
| **ADC精度** | 18位 | 高精度 |
| **通信接口** | I2C | 标准400kHz |

### 4.3 🎯 核心代码展示（演讲用）- STM32心率采集主程序

```c
/*************************************************************************************
 * STM32 + MAX30102 心率血氧采集系统
 * 
 * 接线说明：
 *   MAX30102: VCC→3.3V, GND→GND, SCL→PB7, SDA→PB8, INT→PB9
 *   OLED显示: SCL→PA5, SDA→PA6, RST→PA3, DC→PA4, CS→PA2
 *   串口通信: RXD→PA9, TXD→PA10 (115200波特率)
 *************************************************************************************/

#include "max30102.h"
#include "algorithm.h"
#include "oled.h"

/* 数据缓冲区 */
uint32_t aun_ir_buffer[500];    // 红外LED传感器数据
uint32_t aun_red_buffer[500];   // 红光LED传感器数据
int32_t n_sp02;                 // 血氧值 (%)
int32_t n_heart_rate;           // 心率值 (bpm)

/* ======================== 心率滤波算法 ======================== */
/* 问题：原始心率数据波动大，显示跳动
 * 解决：滑动平均滤波 + 变化率限制
 */
#define HR_FILTER_SIZE 5      // 滑动窗口大小
#define HR_MAX_CHANGE  15     // 单次最大变化幅度

static int32_t hr_buffer[HR_FILTER_SIZE] = {0};
static int32_t last_valid_hr = 0;

/**
 * @brief 心率滑动平均滤波
 * @param new_hr 新采集的心率值
 * @return 滤波后的稳定心率值
 * 
 * 技术亮点：
 * 1. 变化率限制：心率不能突变超过15bpm，防止毛刺
 * 2. 滑动窗口：取最近5次测量的平均值
 * 3. 保持历史值：异常值不影响显示
 */
int32_t hr_filter(int32_t new_hr)
{
    int32_t sum = 0;
    u8 i;
    
    /* 变化率限制：心率不能突变超过15 */
    if(last_valid_hr > 0 && abs(new_hr - last_valid_hr) > HR_MAX_CHANGE)
    {
        return last_valid_hr;  // 变化太大，保持上次值
    }
    
    /* 加入滑动窗口 */
    hr_buffer[hr_buffer_index] = new_hr;
    hr_buffer_index = (hr_buffer_index + 1) % HR_FILTER_SIZE;
    
    /* 计算平均值 */
    for(i = 0; i < HR_FILTER_SIZE; i++)
    {
        sum += hr_buffer[i];
    }
    last_valid_hr = sum / HR_FILTER_SIZE;
    return last_valid_hr;
}

int main(void)
{ 
    /* 硬件初始化 */
    delay_init();
    uart_init(115200);      // 串口：用于数据上传
    OLED_Init();            // OLED显示屏
    max30102_init();        // MAX30102传感器
    
    OLED_ShowCHinese(5,0,0); // 显示"心率血氧测试"
    
    /* 采集500个样本进行初始校准（约5秒） */
    n_ir_buffer_length = 500;
    for(i = 0; i < n_ir_buffer_length; i++)
    {
        while(MAX30102_INT == 1);  // 等待中断信号
        
        /* 读取FIFO数据：3字节红光 + 3字节红外 */
        max30102_FIFO_ReadBytes(REG_FIFO_DATA, temp);
        aun_red_buffer[i] = ((temp[0]&0x03)<<16) | (temp[1]<<8) | temp[2];
        aun_ir_buffer[i]  = ((temp[3]&0x03)<<16) | (temp[4]<<8) | temp[5];
    }
    
    /* 计算初始心率和血氧 */
    maxim_heart_rate_and_oxygen_saturation(
        aun_ir_buffer, n_ir_buffer_length, aun_red_buffer,
        &n_sp02, &ch_spo2_valid,
        &n_heart_rate, &ch_hr_valid
    );
    
    /* 主循环：持续采集和计算 */
    while(1)
    {
        /* 滑动窗口：丢弃旧数据，保留新数据 */
        for(i = 100; i < 500; i++)
        {
            aun_red_buffer[i-100] = aun_red_buffer[i];
            aun_ir_buffer[i-100] = aun_ir_buffer[i];
        }
        
        /* 采集新的100个样本 */
        for(i = 400; i < 500; i++)
        {
            while(MAX30102_INT == 1);
            max30102_FIFO_ReadBytes(REG_FIFO_DATA, temp);
            aun_red_buffer[i] = ((temp[0]&0x03)<<16) | (temp[1]<<8) | temp[2];
            aun_ir_buffer[i]  = ((temp[3]&0x03)<<16) | (temp[4]<<8) | temp[5];
        }
        
        /* 重新计算心率和血氧 */
        maxim_heart_rate_and_oxygen_saturation(...);
        
        /* 手指检测：IR信号 > 50000 表示有手指放上 */
        if(aun_ir_buffer[i] > 50000)
        {
            /* 心率范围限制：50-120 bpm（静息正常范围） */
            if(ch_hr_valid && n_heart_rate >= 50 && n_heart_rate <= 120)
            {
                dis_hr = hr_filter(n_heart_rate);  // 应用滤波
            }
            
            /* 血氧范围限制：90-100%（健康人正常范围） */
            if(ch_spo2_valid && n_sp02 >= 90 && n_sp02 <= 100)
            {
                dis_spo2 = n_sp02;
            }
        }
        
        /* 更新OLED显示 */
        OLED_Display_Timer_Data(50, 3, dis_hr);   // 显示心率
        OLED_Display_Timer_Data(50, 6, dis_spo2); // 显示血氧
        
        /* 通过串口上传数据到后端 */
        printf("{\"hr\":%d,\"spo2\":%d}\r\n", dis_hr, dis_spo2);
    }
}
```

**代码讲解要点**：
1. **I2C通信**：通过I2C总线读取MAX30102的FIFO数据
2. **PPG算法**：利用红光/红外双波长计算心率和血氧
3. **滑动平均滤波**：消除毛刺，输出稳定读数
4. **手指检测**：IR信号强度判断是否正确佩戴
5. **数据上传**：JSON格式串口输出，方便后端解析

---

## 五、数据处理架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           数据流架构图                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐               │
│  │   数据生成    │ →  │   数据清洗    │ →  │   特征工程    │              │
│  │              │    │              │    │              │               │
│  │ • 用户画像    │    │ • 去重       │    │ • 统计特征    │               │
│  │ • 健康数据    │    │ • 异常值检测  │    │ • 趋势特征    │               │
│  │ • CSV/JSON   │    │ • 缺失值填充  │    │ • 达标率计算  │               │
│  └──────────────┘    └──────────────┘    └──────────────┘               │
│         │                   │                   │                        │
│         ↓                   ↓                   ↓                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                       健康评估引擎                                 │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │   │
│  │  │ 单病种评估   │  │ 生活方式评估 │  │ 趋势分析     │                │   │
│  │  │ • 高血压     │  │ • 睡眠      │  │ • 线性回归   │                │   │
│  │  │ • 糖尿病     │  │ • 运动      │  │ • 波动检测   │                │   │
│  │  │ • 血脂异常   │  │ • 饮食      │  │ • 异常预警   │                │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                │   │
│  │                          ↓                                         │   │
│  │  ┌──────────────────────────────────────────────────────────────┐ │   │
│  │  │            综合评估（AHP权重 + TOPSIS排序）                     │ │   │
│  │  │  → 综合健康评分 (0-100)                                        │ │   │
│  │  │  → 健康等级分层（优秀/良好/亚健康/需关注/高风险）                 │ │   │
│  │  │  → TOP风险因素提取                                             │ │   │
│  │  └──────────────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                   ↓                                      │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                          API 输出                                  │   │
│  │   /api/health/today   /api/health/radar   /api/health/assessment  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 六、核心算法详解

### 3.1 异常值检测算法

**文件**: `data_preparation.py` → `DataPreprocessor` 类

#### IQR 方法（四分位距法）
```python
def _remove_outliers_iqr(self, data: np.ndarray):
    q1 = np.percentile(data, 25)
    q3 = np.percentile(data, 75)
    iqr = q3 - q1
    
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    
    mask = (data >= lower_bound) & (data <= upper_bound)
    return data[mask], mask
```

**原理**：基于数据的四分位数，超出 `[Q1-1.5*IQR, Q3+1.5*IQR]` 范围的值视为异常值。

#### Z-Score 方法
```python
def _remove_outliers_zscore(self, data: np.ndarray):
    z_scores = np.abs(stats.zscore(data))
    mask = z_scores < 3.0  # 阈值为3个标准差
    return data[mask], mask
```

**原理**：标准化后，距离均值超过3个标准差的值视为异常值。

---

### 3.2 特征工程

**文件**: `data_preparation.py` → `FeatureEngineer` 类

#### 构建的特征类型

| 特征类型 | 计算方法 | 适用场景 |
|----------|----------|----------|
| **统计特征** | 均值、标准差、最大/最小值 | 基础健康状态描述 |
| **变异特征** | 变异系数 CV = std/mean | 血糖波动、血压稳定性 |
| **趋势特征** | 线性回归斜率 | 体重变化、指标趋势 |
| **达标率** | 正常值比例 | 血压/血糖控制效果 |
| **规律性特征** | 标准差倒数 | 睡眠/作息规律性 |

#### 特征集合定义（FeatureSet）
```python
@dataclass
class FeatureSet:
    # 血压特征
    sbp_mean, sbp_std, sbp_max, sbp_min
    sbp_trend          # 趋势斜率
    sbp_cv             # 变异系数
    sbp_compliance_rate # 达标率
    
    # 血糖特征
    glucose_mean, glucose_cv, glucose_compliance_rate
    
    # 睡眠特征
    sleep_duration_mean, sleep_regularity_score
    sleep_insufficient_days
    
    # 运动特征
    steps_mean, active_days_ratio
    
    # ... 更多指标
```

---

### 3.3 健康评估算法

**文件**: `comprehensive_assessment.py`

#### AHP 层次分析法（权重确定）

**用途**：确定各维度在综合评估中的权重

```python
# 默认权重配置
default_weights = {
    'disease_risk': 0.45,    # 疾病风险权重最高
    'lifestyle_risk': 0.30,  # 生活方式次之
    'trend_risk': 0.25       # 趋势变化
}

# 疾病内部权重
disease_weights = {
    'hypertension': 0.40,
    'diabetes': 0.35,
    'dyslipidemia': 0.25
}
```

**一致性检验**：
```python
def check_consistency(self, comparison_matrix):
    # 计算最大特征值
    lambda_max = np.max(eigenvalues.real)
    # 一致性指标
    ci = (lambda_max - n) / (n - 1)
    # 一致性比率 CR < 0.1 为可接受
    cr = ci / ri
    return cr
```

#### TOPSIS 多准则决策（排序）

**用途**：在多个候选方案中选出最优解

```python
def topsis_rank(self, scores: Dict[str, float], weights: Dict[str, float]):
    # 1. 构建加权标准化矩阵
    # 2. 确定理想解和负理想解
    # 3. 计算到理想解的距离
    # 4. 计算相对贴近度
    closeness = d_negative / (d_positive + d_negative)
    return closeness  # 越接近1越好
```

---

### 3.4 指标评估器

**文件**: `indicator_evaluator.py`

#### 参考范围定义
```python
reference_ranges = {
    'spo2': ReferenceRange(
        name='血氧',
        unit='%',
        normal_low=95, normal_high=100,
        warning_low=90, critical_low=85
    ),
    'systolic_bp': ReferenceRange(
        name='收缩压',
        unit='mmHg',
        normal_low=90, normal_high=140,
        warning_high=160, critical_high=180
    ),
    # ... 更多指标
}
```

#### 状态判断逻辑
```python
def _determine_status(self, value, ref):
    if value >= ref.critical_high:
        return CRITICAL_HIGH, "明显高于参考上限"
    if value <= ref.critical_low:
        return CRITICAL_LOW, "明显低于参考下限"
    if value >= ref.warning_high:
        return HIGH, "高于参考范围"
    if value <= ref.warning_low:
        return LOW, "低于参考范围"
    if value > ref.normal_high:
        return SLIGHTLY_HIGH, "略高于参考上限"
    if value < ref.normal_low:
        return SLIGHTLY_LOW, "略低于参考下限"
    return NORMAL, "位于参考范围内"
```

---

## 七、可视化分析（React + Recharts）

### 7.1 图表类型

| 图表 | 组件 | 用途 |
|------|------|------|
| **心率曲线** | LineChart | 展示24小时心率变化趋势 |
| **血氧趋势** | AreaChart | 血氧饱和度波动 |
| **睡眠分析** | BarChart | 每日睡眠时长柱状图 |
| **健康雷达** | RadarChart | 多维度健康状态 |
| **年龄分布** | PieChart | 社区老人年龄构成 |

### 7.2 可视化代码示例

```tsx
// 心率趋势图 - 使用 Recharts
import { LineChart, Line, XAxis, YAxis, Tooltip, ReferenceLine } from 'recharts';

function HeartRateChart({ data }) {
  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart data={data}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="time" />
        <YAxis domain={[50, 120]} />
        <Tooltip />
        
        {/* 心率曲线 */}
        <Line 
          type="monotone" 
          dataKey="heartRate" 
          stroke="#ef4444" 
          strokeWidth={2}
          dot={false}
        />
        
        {/* 参考线：正常范围 60-100 */}
        <ReferenceLine y={60} stroke="#22c55e" strokeDasharray="5 5" label="正常下限" />
        <ReferenceLine y={100} stroke="#f59e0b" strokeDasharray="5 5" label="正常上限" />
      </LineChart>
    </ResponsiveContainer>
  );
}
```

---

## 八、数据生成模块

### 4.1 用户画像设计

**文件**: `user_profiles.py`

定义了 **10类典型老年人画像**：

| 画像ID | 类型 | 特征 |
|--------|------|------|
| healthy_1/2 | 健康老人 | 指标正常，规律作息 |
| hypertension_1/2 | 高血压患者 | 血压偏高，服药控制中 |
| diabetes_1/2 | 糖尿病前期 | 空腹血糖 6.1-7.0 |
| suboptimal_1/2 | 亚健康老人 | 睡眠差，运动少 |
| multiple_1/2 | 多病共存 | 血压+血糖+血脂异常 |

### 4.2 时间规律模拟

**文件**: `health_generator.py`

```python
def _time_factor(self, hour: int, data_type: str):
    if data_type == "blood_pressure":
        # 晨峰效应：6-10点血压较高
        if 6 <= hour <= 10:
            return random.uniform(5, 15)
        elif 22 <= hour or hour <= 4:
            return random.uniform(-8, -3)
    
    elif data_type == "heart_rate":
        # 睡眠时心率低，活动时高
        if 0 <= hour <= 5:
            return random.uniform(-12, -8)
        elif 10 <= hour <= 18:
            return random.uniform(3, 10)
```

### 4.3 生成的数据类型

| 数据类型 | 每日记录数 | 字段 |
|----------|------------|------|
| blood_pressure | 2次 | systolic, diastolic, pulse |
| glucose | 1-2次 | value, test_type, meal_time |
| heart_rate | 4次 | value, activity_level |
| sleep | 1次 | duration, deep_sleep, quality_score |
| steps | 1次 | value, distance, calories |
| weight | 1次 | value, bmi |
| temperature | 1次 | value, measurement_site |
| spo2 | 2次 | value, perfusion_index |

---

## 九、数据清洗流水线

**文件**: `data_pipeline.py`

### 5.1 清洗步骤

```
数据采集 → 去重 → 异常值检测 → 缺失值填充 → 格式化 → 标准化
```

### 5.2 数据质量报告

```python
@dataclass
class DataQualityReport:
    total_records: int        # 总记录数
    valid_records: int        # 有效记录数
    duplicates_removed: int   # 去重数量
    outliers_detected: int    # 异常值数量
    missing_filled: int       # 缺失填充数量
    
    quality_score: float      # 质量评分 0-100
    completeness: float       # 完整性
    accuracy: float           # 准确性
    consistency: float        # 一致性
```

---

## 十、使用示例

### 6.1 数据生成
```python
from 数据生成.user_generator import generate_users
from 数据生成.health_generator import generate_health_data

# 生成10个用户
users = generate_users(seed=42)

# 生成30天健康数据
records = generate_health_data(users, days=30)
```

### 6.2 特征工程
```python
from 数据层.data_preparation import FeatureEngineer, HealthMetrics

engineer = FeatureEngineer()
features = engineer.build_features(
    user_id='USER001',
    raw_data={'blood_pressure': bp_data},
    assessment_period=(start_date, end_date)
)
```

### 6.3 健康评估
```python
from modules.comprehensive_assessment import ComprehensiveAssessment

assessment = ComprehensiveAssessment()
result = assessment.evaluate(user_id='USER001', features=features)

print(f"综合健康评分: {result.overall_score}")
print(f"健康等级: {result.health_level.value}")
print(f"TOP风险: {result.top_risk_factors}")
```

---

## 十一、依赖库

```txt
numpy>=1.21.0          # 数值计算
pandas>=1.3.0          # 数据处理
scipy>=1.7.0           # 统计分析
scikit-learn>=0.24.0   # 机器学习（可选）
```

---

## 十二、总结

### 技术亮点

| 亮点 | 说明 |
|------|------|
| **硬件数据采集** | STM32 + MAX30102，I2C通信，实时心率血氧 |
| **滑动平均滤波** | 消除传感器毛刺，输出稳定读数 |
| **数据清洗流水线** | IQR + Z-score + 业务规则三重过滤 |
| **前端可视化** | Recharts图表库，实时数据展示 |

### 核心技术栈

| 层级 | 技术 |
|------|------|
| **硬件层** | STM32F103 + MAX30102 + I2C |
| **数据处理** | Python + NumPy + Pandas |
| **可视化** | React + Recharts + TailwindCSS |
| **算法** | IQR / Z-Score / 滑动平均滤波 |

---

*文档更新时间: 2025年12月*
*项目: 养生之道智能健康管理系统*
